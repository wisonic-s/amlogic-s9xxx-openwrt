#!/bin/bash
#===========================================================================
#
# This file is licensed under the terms of the GNU General Public
# License version 2. This program is licensed "as is" without any
# warranty of any kind, whether express or implied.
#
# This file is a part of the make OpenWrt for Amlogic s9xxx tv box
# https://github.com/ophub/amlogic-s9xxx-openwrt
#
# Description: Create TF/SD/USB remaining space partition
# Copyright (C) 2021- https://github.com/unifreq/openwrt_packit
# Copyright (C) 2021- https://github.com/ophub/amlogic-s9xxx-openwrt
#
# Command: openwrt-tf
#
#========================= Set default parameters ===========================
#
STEPS="[\033[95m STEPS \033[0m]"
INFO="[\033[94m INFO \033[0m]"
SUCCESS="[\033[92m SUCCESS \033[0m]"
OPTIONS="[\033[93m OPTIONS \033[0m]"
ERROR="[\033[91m ERROR \033[0m]"
#
#===========================================================================

# Encountered a serious error, abort the script execution
error_msg() {
    echo -e "${ERROR} ${1}"
    exit 1
}

# Check disk
do_checkdisk() {
    # Find the partition where root is located
    ROOT_PTNAME="$(df / | tail -n1 | awk '{print $1}' | awk -F '/' '{print $3}')"
    [[ -z "${ROOT_PTNAME}" ]] && error_msg "Cannot find the partition corresponding to the root file system!"

    # Check the current system running disk
    if lsblk -l | grep -E "^${ROOT_PTNAME:0:-2}boot0" >/dev/null; then
        error_msg "You are running in eMMC mode, please boot system with usb or tf card!"
    fi

    # Find the disk where the partition is located, only supports mmcblk?p? sd?? hd?? vd?? and other formats
    case "${ROOT_PTNAME}" in
    mmcblk?p[1-4])
        DISK_NAME="$(echo ${ROOT_PTNAME} | awk '{print substr($1, 1, length($1)-2)}')"
        PT_PRE="${DISK_NAME}p"
        LB_PRE="MMC_"
        ;;
    [hsv]d[a-z][1-4])
        DISK_NAME="$(echo ${ROOT_PTNAME} | awk '{print substr($1, 1, length($1)-1)}')"
        PT_PRE="${DISK_NAME}"
        LB_PRE="USB_"
        ;;
    nvme?n?p[1-4])
        DISK_NAME="$(echo ${ROOT_PTNAME} | awk '{print substr($1, 1, length($1)-2)}')"
        PT_PRE="${DISK_NAME}p"
        LB_PRE="NVME_"
        ;;
    *)
        error_msg "Unable to recognize the disk type of ${ROOT_PTNAME}!"
        ;;
    esac
}

# Get the starting position of the p3 partition
create_new_part() {
    # Generate New UUID
    echo -e "${STEPS} Start generating new partition UUID..."
    ROOTFS_UUID="$(cat /proc/sys/kernel/random/uuid)"
    [[ -z "${ROOTFS_UUID}" ]] && ROOTFS_UUID="$(uuidgen)"
    SHARED_UUID="$(cat /proc/sys/kernel/random/uuid)"
    [[ -z "${SHARED_UUID}" ]] && SHARED_UUID="$(uuidgen)"
    [[ -z "${ROOTFS_UUID}" || -z "${SHARED_UUID}" ]] && error_msg "The new UUID is invalid, cannot continue."

    # Repair disk size
    echo -e "${STEPS} Start repairing hard disk size..."
    printf 'f\n' | parted ---pretend-input-tty /dev/${DISK_NAME} print || repair_status="no"
    [[ "${repair_status}" == "no" ]] && error_msg "Disk size repair failed, stop partitioning."

    # Calculate partition positions
    echo -e "${STEPS} Start calculating partition location..."
    END_P2="$(fdisk -l | grep "${ROOT_PTNAME}" | sed -n '$p' | awk '{print $3}' | xargs)"
    [[ -z "${END_P2}" || -z "$(echo ${END_P2} | sed -n "/^[0-9]\+$/p")" ]] && error_msg "Unable to get starting position!"
    START_P3="$(((END_P2 + 1) / 2048 + 1))"

    # Create the partition
    echo -e "${STEPS} Start creating new partitions..."
    ROOTFS_MB="1024"
    parted /dev/${DISK_NAME} mkpart primary btrfs $((START_P3))MiB $((START_P3 + ROOTFS_MB - 1))MiB 2>/dev/null
    parted /dev/${DISK_NAME} mkpart primary btrfs $((START_P3 + ROOTFS_MB))MiB 100% 2>/dev/null
    # Show partition results
    parted /dev/${DISK_NAME} unit MiB print

    echo -e "${STEPS} Start formatting new partition..."
    # Format the third partition
    mkdir -p /mnt/${PT_PRE}3
    umount -f /dev/${PT_PRE}3 2>/dev/null
    mkfs.btrfs -f -U ${ROOTFS_UUID} -L "${LB_PRE}ROOTFS2" -m single "/dev/${PT_PRE}3"
    [[ "${?}" -eq "0" ]] || error_msg "The [ /dev/${PT_PRE}3 ] partition format failed!"
    mount -t btrfs -o compress=zstd:6 "/dev/${PT_PRE}3" "/mnt/${PT_PRE}3"
    [[ "${?}" -eq "0" ]] || error_msg "Mount [ /mnt/${PT_PRE}3 ] failed!"

    # Format the fourth partition
    mkdir -p /mnt/${PT_PRE}4
    umount -f /dev/${PT_PRE}4 2>/dev/null
    mkfs.btrfs -f -U ${SHARED_UUID} -L "${LB_PRE}SHARED" -m single "/dev/${PT_PRE}4"
    [[ "${?}" -eq "0" ]] || error_msg "The [ /dev/${PT_PRE}4 ] partition format failed!"
    mount -t btrfs -o compress=zstd:6 "/dev/${PT_PRE}4" "/mnt/${PT_PRE}4"
    [[ "${?}" -eq "0" ]] || error_msg "Mount [ /mnt/${PT_PRE}4 ] failed!"

    # Adjust docker data storage location
    echo -e "${STEPS} Start adjusting docker settings..."
    /etc/init.d/dockerd stop 2>/dev/null
    /etc/init.d/dockerd disable 2>/dev/null
    rm -rf "/opt/docker" 2>/dev/null
    mkdir -p /mnt/${PT_PRE}4/docker
    ln -sf "/mnt/${PT_PRE}4/docker/" "/opt/docker"

    if [[ -f "/etc/config/dockerd" ]]; then
        uci set dockerd.@globals[0].data_root="/mnt/${PT_PRE}4/docker/"
        uci commit dockerd
    fi
    cat >/etc/docker/daemon.json <<EOF
{
  "bip": "172.31.0.1/24",
  "data-root": "/mnt/${PT_PRE}4/docker/",
  "log-level": "warn",
  "log-driver": "json-file",
  "log-opts": {
     "max-size": "10m",
     "max-file": "5"
   },
  "registry-mirrors": [
     "https://mirror.baidubce.com/",
     "https://hub-mirror.c.163.com"
   ]
}
EOF

    /etc/init.d/dockerd start 2>/dev/null
    /etc/init.d/dockerd enable 2>/dev/null

    echo -e "${INFO} Current partition status: \n$(lsblk)"
    echo -e "${SUCCESS} Create partition successfully."
    sync
    exit 0
}

echo -e "${STEPS} Welcome to use TF/SD/USB partition management tool."
# Check script permission
[[ -x "/usr/sbin/openwrt-tf" ]] || error_msg "Please grant execution permission: [ chmod +x /usr/sbin/openwrt-tf ]"
#
echo -ne "${STEPS} This operation will clear the data in the remaining space, are you sure to continue? y/n [y]\b\b"
read yn
case "${yn}" in
    n* | N*) error_msg " You aborted the operation!" ;;
esac
#
# Check disk
do_checkdisk
# Get the starting position of the p3 partition
create_new_part
